
import os
import json
import textwrap
from typing import Dict, Any, List
from .prompts import FILE_PROMPT, REFACTOR_PROMPT

class CodeWriter:
    def __init__(self, llm, project_dir: str, package_name: str):
        self.llm = llm
        self.project_dir = project_dir
        self.package_name = package_name
        os.makedirs(os.path.join(project_dir, package_name), exist_ok=True)
        # Basic scaffolding
        with open(os.path.join(project_dir, "pyproject.toml"), "w") as f:
            f.write(textwrap.dedent(f"""
            [project]
            name = "{package_name}"
            version = "0.1.0"
            description = "Generated by Local Code Writer Agent"
            requires-python = ">=3.10"
            dependencies = []

            [tool.ruff]
            line-length = 100

            [tool.pytest.ini_options]
            testpaths = ["tests"]
            """))
        os.makedirs(os.path.join(project_dir, "tests"), exist_ok=True)

        with open(os.path.join(project_dir, "README.md"), "w") as f:
            f.write(f"# {package_name}\n\nGenerated project.\n")

        # __init__
        init_path = os.path.join(project_dir, package_name, "__init__.py")
        if not os.path.exists(init_path):
            with open(init_path, "w") as f:
                f.write("__all__ = []\n")

    def write_file(self, rel_path: str, content: str):
        full = os.path.join(self.project_dir, rel_path)
        os.makedirs(os.path.dirname(full), exist_ok=True)
        with open(full, "w") as f:
            f.write(content)

    def materialize(self, plan: Dict[str, Any]):
        # Modules
        for mod in plan.get("modules", []):
            path = mod.get("path")
            doc = mod.get("doc", "")
            prompt = FILE_PROMPT.format(package=self.package_name, path=path, doc=doc)
            code = self.llm.chat([{"role":"system","content":"You are a precise Python code generator."},
                                  {"role":"user","content": prompt}])
            # Extract code block
            import re
            m = re.search(r"```python\s*(.*?)\s*```", code, re.DOTALL)
            body = m.group(1) if m else code
            self.write_file(path, body)

        # Tests
       # for t in plan.get("tests", []):
        #    path = t.get("path", "tests/test_core.py")
       #     doc = t.get("doc", "")
      #      test_prompt = FILE_PROMPT.format(package=self.package_name, path=path, doc=doc)
     #       code = self.llm.chat([{"role":"system","content":"You write excellent pytest tests."},
    #                              {"role":"user","content": test_prompt}])
   #         import re
  #          m = re.search(r"```python\s*(.*?)\s*```", code, re.DOTALL)
 #           body = m.group(1) if m else code
#            self.write_file(path, body)

    def refine_from_tooling(self, tooling_output: str):
        # Ask LLM to patch files based on tool errors
        prompt = REFACTOR_PROMPT.format(tooling_output=tooling_output)
        patch = self.llm.chat([{"role":"system","content":"You refactor code to satisfy tests and linters."},
                               {"role":"user","content": prompt}])
        # Very simple patch strategy: LLM returns a JSON list of {path, content}
        import json, re
        try:
            code = re.search(r"```json\s*(.*?)\s*```", patch, re.DOTALL)
            txt = code.group(1) if code else patch
            edits = json.loads(txt)
            if isinstance(edits, list):
                for e in edits:
                    self.write_file(e["path"], e["content"])
        except Exception:
            pass
